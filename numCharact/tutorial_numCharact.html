<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="generator" content="MATLAB R2016a"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><title>Numerical properties of a reconstruction</title><style type="text/css">
* {margin: 0; padding: 0;}
body {text-align: start; line-height: 17.234001159668px; min-height: 0px; white-space: normal; color: rgb(0, 0, 0); font-family: Consolas, Inconsolata, Menlo, monospace; font-style: normal; font-size: 13.9999990463257px; font-weight: normal; text-decoration: none; white-space: normal; }
h1, h2 {font-weight: normal;}
.content { padding: 30px; }

.S0 { margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S1 { line-height: 26.3999977111816px; min-height: 24px; white-space: pre-wrap; color: rgb(213, 80, 0); font-family: Helvetica, Arial, sans-serif; font-size: 22px; white-space: pre-wrap; margin-left: 4px; margin-top: 3px; margin-bottom: 15px; margin-right: 10px;  }
.S2 { min-height: 0px; font-weight: bold; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S3 { line-height: 21px; min-height: 17px; white-space: pre-wrap; font-family: Helvetica, Arial, sans-serif; white-space: pre-wrap; margin-left: 4px; margin-top: 2px; margin-bottom: 9px; margin-right: 10px;  }
.S4 { line-height: 20.576000213623px; min-height: 20px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-size: 16px; font-weight: bold; white-space: pre-wrap; margin-left: 4px; margin-top: 15px; margin-bottom: 9px; margin-right: 10px;  }
.S5 { min-height: 0px; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S6 { line-height: 20.576000213623px; min-height: 20px; white-space: pre-wrap; color: rgb(60, 60, 60); font-family: Helvetica, Arial, sans-serif; font-size: 16px; font-weight: bold; white-space: pre-wrap; margin-left: 4px; margin-top: 3px; margin-bottom: 9px; margin-right: 10px;  }
.S7 { min-height: 0px; font-family: monospace; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S8 { margin-left: 3px; margin-top: 10px; margin-bottom: 10px; margin-right: 3px;  }
.S9 { line-height: 15.5926675796509px; min-height: 18px; white-space: nowrap; font-size: 12.6666669845581px; white-space: nowrap; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S10 { line-height: 15.5926685333252px; min-height: 0px; white-space: pre; white-space: pre; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 45px;  }
.S11 { line-height: 15.5926685333252px; min-height: 0px; white-space: pre; white-space: pre; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S12 { line-height: 15.5926685333252px; min-height: 0px; white-space: pre; color: rgb(160, 32, 240); white-space: pre; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S13 { line-height: 21px; min-height: 17px; white-space: pre-wrap; font-family: Helvetica, Arial, sans-serif; white-space: pre-wrap; margin-left: 4px; margin-top: 10px; margin-bottom: 9px; margin-right: 10px;  }
.S14 { min-height: 0px; color: rgb(0, 95, 206); margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S15 { margin-left: 3px; margin-top: 10px; margin-bottom: 4px; margin-right: 3px;  }
.S16 { line-height: 15.5926685333252px; min-height: 0px; white-space: pre; color: rgb(160, 32, 240); white-space: pre; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 45px;  }
.S17 { min-height: 0px; font-style: italic; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S18 { line-height: 15.5926685333252px; min-height: 0px; white-space: pre; color: rgb(34, 139, 34); white-space: pre; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 45px;  }
.S19 { line-height: 15.5926685333252px; min-height: 0px; white-space: pre; color: rgb(0, 0, 255); white-space: pre; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S20 { line-height: 15.5926685333252px; min-height: 0px; white-space: pre; color: rgb(0, 0, 255); white-space: pre; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 45px;  }
.S21 { font-family: Helvetica, Arial, sans-serif; margin-left: 0px; margin-top: 10px; margin-bottom: 20px; margin-right: 0px;  }
.S22 { text-align: left; line-height: 20.9999980926514px; white-space: pre-wrap; white-space: pre-wrap; margin-left: 55.9999961853027px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S23 { font-weight: bold; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S24 { font-style: italic; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }
.S25 { text-decoration: underline; margin-left: 0px; margin-top: 0px; margin-bottom: 0px; margin-right: 0px;  }

.LineNodeBlock {margin: 10px 0 10px 0;}
.LineNodeBlock+.paragraphNode {margin-top: 10px;}
.lineNode {padding-left: 10px; background-color: #F7F7F7; border-left: 1px solid #E9E9E9; border-right: 1px solid #E9E9E9;}
.inlineWrapper:first-child .lineNode,.inlineWrapper.outputs+.inlineWrapper .lineNode {padding-top: 5px; border-top: 1px solid #E9E9E9;}
.inlineWrapper:last-child .lineNode,.inlineWrapper.outputs .lineNode {padding-bottom: 5px; border-bottom: 1px solid #E9E9E9;}
.lineNode .textBox {white-space: pre;}
</style></head><body><div class = "content"><div class = 'SectionBlock containment active'><h1 class = "S1"><span class = "S2">Numerical properties of a reconstruction</span></h1><p class = "S3"><span class = "S2">Authors: Laurent Heirendt, Ronan M.T. Fleming, Luxembourg Centre for Systems Biomedicine</span></p><p class = "S3"><span class = "S2">Reviewers: Sylvain Arreckx, Thomas Pfau, and Catherine Fleming,  Luxembourg Centre for Systems Biomedicine</span></p><h2 class = "S4"><span class = "S5">Introduction</span></h2><p class = "S3"><span class = "S5">During this tutorial, you will learn how to determine and explore the numerical properties of a stoichiometric matrix. The numerical properties are key to analyzing the metabolic reconstruction at hand, to select the appropriate solver, or to determine incoherencies in the network. </span></p><p class = "S3"><span class = "S5">You will also be able to learn more about the definitions of the various numerical characteristics. This tutorial is particularly useful when you have a multi-scale model and are facing numerical issues when performing flux balance analysis or any other variants of FBA.</span></p></div><p class = "S0"></p><div class = 'SectionBlock containment'><h2 class = "S6"><span class = "S5">EQUIPMENT SETUP</span></h2><h2 class = "S4"><span class = "S5">Initialize the COBRA Toolbox.</span></h2><p class = "S3"><span class = "S5">Please ensure that The COBRA Toolbox has been properly installed, and initialized using the </span><span class = "S7">initCobraToolbox</span><span class = "S5"> function.</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">initCobraToolbox</span></p></div></div><h2 class = "S4"><span class = "S5">Setting the </span><span class = "S5">optimization</span><span class = "S5"> solver.</span></h2><p class = "S3"><span class = "S5">This tutoria</span><span class = "S5">l will be ru</span><span class = "S5">n </span><span class = "S5">with a </span><span class = "S7">'glpk</span><span class = "S7">'</span><span class = "S5"> package, which is a linear programming ('</span><span class = "S7">LP'</span><span class = "S5">) solver. The </span><span class = "S7">'glpk</span><span class = "S7">'</span><span class = "S5"> package does not require additional instalation and configuration.</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">solverName=</span><span class = "S12">'glpk'</span><span class = "S10">;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">solverType=</span><span class = "S12">'LP'</span><span class = "S10">; </span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">changeCobraSolver(solverName,solverType);</span></p></div></div><p class = "S13"><span class = "S5">There are no specific solvers essentail to running this tutorial. For the analysis of large models, such as Recon [1], it is not recommended to use the </span><span class = "S7">'glpk</span><span class = "S7">'</span><span class = "S5"> package but rather an industrial strength solver, such as the </span><span class = "S7">'gurobi'</span><span class = "S5"> package. For detailed information, refer to The Cobra Toolbox </span><a href = 'https://github.com/opencobra/cobratoolbox/blob/master/docs/source/installation/solvers.md'><span class = "S0">solver instalation guide</span></a><span class = "S5">. </span></p><p class = "S3"><span class = "S5">A solver package may offer different types of optimization programmes to solve a problem. The above example used a LP optimization, other types of optimization programmes include; mixed-integer linear programming ('</span><span class = "S7">MILP</span><span class = "S5">'), quadratic programming ('</span><span class = "S7">QP</span><span class = "S5">'), and mixed-integer quadratic programming ('</span><span class = "S7">MIQP</span><span class = "S5">').</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">warning </span><span class = "S16">off MATLAB:subscripting:noSubscriptsSpecified</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><h2 class = "S6"><span class = "S5">PROCEDURE </span></h2><p class = "S3"><span class = "S5">TIMING: 5 seconds - several hours (depending on the model size)</span></p><p class = "S3"><span class = "S2">Define the name of the model</span></p><p class = "S3"><span class = "S5">Throughout this tutorial, we will use the </span><span class = "S17">E.coli core</span><span class = "S5"> model [2]. It is generally good practice to define; the name of the file that contains the model, the name of the model structure, and the name of the stoichiometric matrix, as separate variables. Therefore, we propose that within the </span><span class = "S7">modelFile</span><span class = "S5">, there is a structure named </span><span class = "S7">modelName</span><span class = "S5"> with a field </span><span class = "S7">matrixName</span><span class = "S5"> that contains the stoichiometric matrix </span><span class = "S7">S</span><span class = "S5"> (or </span><span class = "S7">A</span><span class = "S5">).</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% define the filename of the model</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">modelFile = </span><span class = "S12">'ecoli_core_model.mat'</span><span class = "S10">;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% define the name of model structure</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">modelName = </span><span class = "S12">'model'</span><span class = "S10">;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% define the fieldname of the stoichiometric matrix</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">matrixName = </span><span class = "S12">'S'</span><span class = "S10">;</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S3"><span class = "S2">Load the stoichiometric matrix</span></p><p class = "S3"><span class = "S5">In order to use the model, we need to load the </span><span class = "S7">modelFile</span><span class = "S5"> that contains a COBRA model structure  </span><span class = "S7">modelName</span><span class = "S5">:</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% load the modelName structure from the modelFile</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">load(modelFile, modelName);</span></p></div></div><p class = "S13"><span class = "S5">Some models contain stoichiometric matrices with a different name (commonly coupled models). By default, the stoichiometric matrix is denoted </span><span class = "S7">S</span><span class = "S5">.</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% select the matrix</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">S = model.S;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S19">if </span><span class = "S11">isfield(model, matrixName) == 1 &amp;&amp; strcmp(matrixName, </span><span class = "S12">'A'</span><span class = "S10">) == 1</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">    S = model.A;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S20">end</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S3"><span class = "S2">Basic numerical characteristics</span></p><p class = "S3"><span class = "S5">The </span><span class = "S2">number of elements</span><span class = "S5"> represents the total number of entries in the stoichiometric matrix (including zero elements). This number is equivalent to the product of the number of reactions and the number of metabolites.</span></p><p class = "S3"><span class = "S5">The number of rows represents the </span><span class = "S2">number of metabolites</span><span class = "S5"> in the metabolic network. The number of columns corresponds to the </span><span class = "S2">number of biochemical reactions</span><span class = "S5"> in the network.</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% determine the number of reactions and metabolites in S</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">[nMets, nRxns] = size(S)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% determine the number of elements in S</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">nElem = numel(S)  </span><span class = "S18">% Nmets * Nrxns</span></p></div></div><p class = "S13"><span class = "S5">The total number of nonzero elements corresponds to the total number of nonzero entries in the stoichiometric matrix (excluding zero elements).</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% determine the number of nonzero elements in S</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">nNz = nnz(S)</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S3"><span class = "S2">Sparsity and Density</span></p><p class = "S3"><span class = "S5">The </span><span class = "S2">sparsity ratio</span><span class = "S5"> corresponds to a </span><span class = "S5">ratio of the number of zero elements and the total number of elements. The sparser a stoichiometric matrix, the fewer metabolites participate in each reaction. The sparsity ratio is particularly useful to compare models by how many metabolites participate in each reaction.</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% determine the sparsity ratio of S (in percent)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">sparsityRatio = (1 - nNz / nElem) * 100.0  </span><span class = "S18">% [%]</span></p></div></div><p class = "S13"><span class = "S5">Similarly, the </span><span class = "S2">complementary sparsity ratio</span><span class = "S5"> is calculated as the difference of 100 and the sparsity ratio expressed in percent, and therefore, is a ratio of the number of nonzero elements and the total number of elements.</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% determine the complementary sparsity ratio (in percent)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">compSparsityRatio = 100.0 - sparsityRatio  </span><span class = "S18">% [%]</span></p></div></div><p class = "S13"><span class = "S5">The</span><span class = "S2"> average column density </span><span class = "S5">corresponds to a ratio of the number of nonzero elements in each column (i.e. reaction) and the total number of metabolites. The average column density corresponds to the arithmetic average of all the column densities (sum of all the reaction densities divided by the number of reactions).</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% add the number of non-zeros in each column (reaction)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">colDensityAv = 0;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S19">for </span><span class = "S10">i = 1:nRxns</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">    colDensityAv = colDensityAv + nnz(S(:, i));</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S20">end</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% calculate the arithmetic average number of non-zeros in each column</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">colDensityAv = colDensityAv / nRxns   </span><span class = "S18">% [-]</span></p></div></div><p class = "S13"><span class = "S5">The average column density provides a measure of how many stoichiometric coefficients participate in each biochemical reaction on average.</span></p><p class = "S3"><span class = "S5">The </span><span class = "S2">relative column density</span><span class = "S5"> corresponds to the ratio of the number of nonzero elements in each column and the total number of metabolites. The relative column density corresponds to the average column density divided by the total number of metabolites (expressed in percent). The relative column density may also be expressed as parts-per-million [ppm] for large-scale or huge-scale models. </span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% determine the density proportional to the length of the column</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">colDensityRel = colDensityAv / nMets * 100  </span><span class = "S18">% [%]</span></p></div></div><p class = "S13"><span class = "S5">The relative column density indicates how many metabolites are being used on average in each reaction relative to the total number of metabolites in the metabolic network.</span></p></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S3"><span class = "S2">Sparsity Pattern (spy plot)</span></p><p class = "S3"><span class = "S5">The visualisation of the sparsity pattern is useful to explore the matrix, spot inconsistencies, or identify patterns visually. In addition to the standard sparsity pattern, the magnitude of the elements of the stoichiometric matrix (stoichiometric coefficients) is shown as proportional to the size of the dot.</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% print a colorful spy map of the S matrix</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">spyc(S, colormap(advancedColormap(</span><span class = "S12">'cobratoolbox'</span><span class = "S10">)));</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% set the font size of the current figure axes</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">set(gca, </span><span class = "S12">'fontsize'</span><span class = "S10">, 14);</span></p></div></div><p class = "S13"><span class = "S5">In the case of the </span><span class = "S17">E.coli core</span><span class = "S5"> model [2],  the biomass reaction is clearly visible (reaction number 13) due to its large amount of metabolites (dots in the column) and large coefficients (size of the dots). Also, the metabolites with large stoichiometric coefficients can be easily determined based on their dot size.</span></p></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S3"><span class = "S2">Rank</span></p><p class = "S3"><span class = "S5">The </span><span class = "S2">rank</span><span class = "S5"> of a stoichiometric matrix is the maximum number of linearly independent rows, and is equivalent to the number of linearly independent columns. The rank is a measurement of how many reactions and metabolites are linearly independent. </span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% determine the rank of the stoichiometric matrix</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S19">if </span><span class = "S10">ispc</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">    rankS = rank(full(S))</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S20">else</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    rankS = getRankLUSOL(S) </span><span class = "S18">% calculated using either the LUSOL solver [3]</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S20">end</span></p></div></div><p class = "S13"><span class = "S5">The </span><span class = "S2">rank deficiency</span><span class = "S5"> of the stoichiometric matrix is a measure of how many reactions and metabolites are not linearly dependent, and expressed as a ratio of the rank of the stoichiometric matrix to the theoretical full rank.</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% calculate the rank deficiency (in percent)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">rankDeficiencyS = (1 - rankS / min(nMets, nRxns)) * 100  </span><span class = "S18">% [%]</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S3"><span class = "S2">Singular Values and Condition Number</span></p><p class = "S3"><span class = "S5">A singular value decomposition of the stoichiometric matrix is the decomposition into orthonormal matrices </span><span style="vertical-align:-3"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAkCAYAAADo6zjiAAACNklEQVRYR+3WS+hNURQG8N8fSZIyEYXklbeBTChMlAxMJUTyCClDA3kVYqIkJa9QUkYGBspAHgPvIhJFoRQiDBSSlvat0+3cvY/+AwZ3T27dvfa3vvXttb91evzj1fOP8+sS6CrwXyvQF4MKr+Rzzf5gapu7Ljb7CsbheYHAVDyuxIzGy5oz7zARn9r3mlzBeNzA0HT4DRbgaYbcTNxN+7uwF9/r4psQCEkfYEwCWIjLBWWGVAhM6pQ8MJoQmIXbleqn10nZRmg2bmITjuTINiGwBQcTyAmsw6+CAluxD1PwpDcE+uAa5iSQpThfSN4PVzEc0aTfekNgBF5XAMbiRYHASLzCbuwoDbvSFSzCpQTyLFX0owC6GBcxL6mXDS8ROITNCWEb9pQqQpxZku7/Qyk+R2Ag7mByApmL6wXA1pmHWNagWbPPcBoCKFZHJ2sjFG8+un4lzpSqL/nAcpxNIOewokFFq3AKExrY+B/oTlcQ/x/GxkQggE8XKoozFxDKxfMrNWuWwADcQrherPahU8dlGN6iabM2JhDDJxztS0GB1pWFdbcGUbENOl1BVYGviNEcjdhpteLj+6HoflWQHIF76QlG4gB9nyGwIQ2dtTheLLsSkPOB6hA6ifX4WQO+BscQVxWeEYo1XjkCIeuVyiAKU9qOR4lIfOHsxPyUNH7vN86cAktWHJNtNY5mgA9gPz7+bfKSEVXxwmJnYFTyjv5J8lAj1xtFTiUFigC9DegS6CrQVeA3nVplJQswKzwAAAAASUVORK5CYII=" width="16" height="18" /></span><span class = "S5"> (of dimension </span><span class = "S7">nMets</span><span class = "S5"> by </span><span class = "S7">nMets</span><span class = "S5">) and </span><span style="vertical-align:-3"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAkCAYAAACaJFpUAAACDElEQVRIS+3Wy8tNYRQG8N9XlJCQv0CSKAwYGSgMFLlEyq2kGJARAwPlUpgZyKWUJBETEQZSksuASCkmioEZAwMp5Naqd2vb55y93318nYnvnZza71rrWetZz3rXGTLgMzRgPCOAw874/0vpWIzuwedXfOlyN4EOEXbY9qL0DLb1ANyJU5W7MXiGmZXvN7AKP4vvdT1chpulAAdxBN9qlLQAD9N9JHYav8r2dYBB6SPMTw6LcbdBtitxDQ+wCN+r9k0qPY5dpYyrVJbjBa33U4Jz8KJbck2AG3AxOZ7F9nI/KgHX4QoOYX8vJpoAF+Jecr6FoOxHl2CT8BTjMQMf+wWchtfJ+X1NsL04ijW4WtfnpgrH4UmSewDOw7tKwCKpYCBGoEMouSoNu1GJ0pB7nFBsUFceq/PYjFl41aDirPVUVup6XC4FLXq8D4ebwOK+idKw2YQLXUYjxuAxJmN2nVDaUBq2S3AnOUV1G9NobME5LEf0L+vkVFhWavGCTMTLVOHqHqPSNYEcwNgCzzEVodT43YMDmF4am2GrsPxkBWA84iexG8eyUCqyzvEJgB0lwzeYi085zm1FE/ZbEW9pcZbidluw3LEIuxW4ngAupUH/s1TbAOeIJuIVSg0KY/W8bQPSD6VT8CHtxhP9grWhNN7UtYj/KJ8HAfgvGH/55vZwBDCbgRFKs6nKNfwNuTVaJbmI08oAAAAASUVORK5CYII=" width="14" height="18" /></span><span class = "S5"> (of dimension </span><span class = "S7">nRxns</span><span class = "S5"> by </span><span class = "S7">nRxns</span><span class = "S5">), and a matrix with diagonal elements </span><span style="vertical-align:-3"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAkCAYAAACaJFpUAAACMElEQVRIS+3WS6hNYRQH8N8lZaREMmXkGQYmlBQjEWIkrxF5DEyUDJSRjEwwUderJIqBlPIoSZRXEmHARBRKMaA80qrv3D777n2+fUpndNZwr8d/rf9a31p7SJ9lqM94BoD/nfEBpRPoOli/8Bs/2nLfjdJpeNMy0DecxxVcw88mvzY9DOAbmJ6CPMAevMdEzMF2LE76j1iOZ3WgbQDH4xFmpQDrcKkm2Gaczr4vxMOqXRvAmXiRHIO6eXjbQNk+HEq6aMd8hM+ItAHcipPJ4zVmI4alTibjOaYk5Tac6AUwErqIoDFkf1ZB01wcw86kvIuleYKlCmMoXmYZL8GdwuSuT0mGWQzQDHzp+JQAFyGyrHVuAM4BR/W8BJgPwTlswp8eKgzTSPpemwrHpepivEO24EwBLNQ7cDxjJYbscxvA6qaJXrwqAAZjl7E62b1L73fkaXSjNO9FvKnYKN8LgFPxIbOJVbcmb0MTYHw/mo33YUQ/S7IRZzOjeMP59mm8BHElotGddbYMtwpo4fMk27m1rDRVuACPs8YHnZ8KgAdxILP5ZzpLQ5NP2tU0BHH3mmQFwq4juxEbZ5TUVTgGN9NKCodR+7ASZWW6g53Pu7Jn0Qqw+hxi4z+teI5F0B67dW3Sxeivwu1u1OcVRpBJOIINmdN1nMLXdHDnYm8laBzk4eopKlFa7UNTolHJBcTlv59uZeMvRTVIaZeW3l3P+gFgz5SVHAaUlhjqWd93Sv8C1NFqJU43O5EAAAAASUVORK5CYII=" width="14" height="18" /></span><span class = "S5"> such that </span><span style="vertical-align:-3"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIUAAAAmCAYAAADqUlh8AAAHiUlEQVR4Xu2adahlVRSHvzGwO1DwDwsVuxsVC7sDWxRF7EJUBANb7O7uxkJFMbEVxQATsbs7+WTvYc/25J33LmfgLBiGd8/OtX4r9xpDTz0HMg6M6TnScyDnQA+KHhP/40APih4UPSh6DNRzoLcU9TyaUEco2+WAf4BJwiX+DP9PDEwK+Lf//gBejBftQTGhirz+3DMDX4RhNwAvASeFv58DrgGWAbYH7gI2Af72ew+KeuZOqCNWBS4ClgJ+DLJ+GFgtgOH5cLG9w/crmlqKaYHNgDWCCfoWeAZ4CPggoGsa4OqOcG6KcOHfSs6jGf0EeDf7rlbNH0xp+kkzK0M/BhYCfq25p2b4e+BLQF41pSmDOS8a712K9lU2uVKnY08Ezgpnd905gfeAD4FFgW/CZrsBzwIvNwHFSsATFbd6JSx+DrBv8F1NmTBa4+YAzgM2LNngB2BH4I7su1p1EzBrwbwjgceAE4DlWxxcH30xcH8QRtVUNVrhFNFe4U7pt8mBF4AFswmpG1ABYgzhsI3DvS8NexlrSALy53SdMvcxL/BWGPh08DvvAGqOGnUMsHn4Po4/asG00RzqRRXy+mETwbAyIJCrSA2KGnMYcHL0s2GSoHsUmDv8/SSwa7AK8kZt1Dwfl21yM3AA8FHF5p717uT70cDxwO8Vc1LFFTznVyinVmMfYBvAGKOUikDhb2r/noDMFI2anJxkxiXAfcBGBaZ3NIXeZO0tAzAc2wa45wJbAIsHV5PvFZnr72q3PMhJUG4bLEX8VgdMswFBZvAn6bKNAaooav/jwOoVMpgquAhlOU+B+xxnjyJQeCGj0wgG//dCOTn3dmAFYIHERzUR2DDGKFg1VFIztsu0vuwMERRld0pBUWTa03W1HMZf0bJ8Diwd4rGi/dusrQvRrQmixWqs4CLh+5vAwiEFLZVBESjczGBSUyoY3NAApYhWDMDoOijaWIqtgLMrgN5GcPJM3ryRMK9Kq7Uu14ax+v7dK4DsOW8Mrty4p4r2CK5Fl3RUnUbWWQrnG1NsAHxVsJgAeg1Yq84k1R1kFL6nlqINKHQ7us+RsBTxWvsDpyd3VLtjSphe3YD3kfDDPSE4/KuANzOE+VM3sNLRoutqXF/rUkllMYVuwUUiafaM6E1dcpoMKEsB6/Yfze9dAsVsWXxSprFpgC/Py4B5aMiGDPZvq2Gi6baKK+k6YkGrdFpZ9hF9UD5Rs6r5+Xo8pDljUmJts4wp1ncNagVxzS6BItVWz1dmudKAsCz+iMDRkliFTNPOIn5G6+OemwJFlmeceVUVTV3CAyVS05/dMkBtIrqbGHi1AYVjrb4ZCDahLoHC83puMzrJ4pla+0t2EYGv+zDVlHI3o7yuBHYIxbTXaxiRjq8LiscuVVfmFpW3hqAz39+izE7AZ00kFMaoCdYKBgXFwcCpDffrGijSILLKNaSBbF5TiFp/REEtJGeLwLoq4bVJg1mYtZe3q3hYBwrnOmZr4PqChbycRaFY6GoiL7MZLcYg9D7wacOJXQOFhSMFLlWBwgeq+GyQanfMCnW/aZm6ITuaD2sCirjaLMCxIU1Kd/CCvgtY7+8SDQoK/fSFI5x9yJfUAlSlpWsCDwZGpvWVnYHLQyZoPDFq1AYU8RB5OdbfDw/R8KgddICFBwWFOb++fyRT0jxWyN8f0uulGUgEz/Qhg7B+1ChYHIBfY6cUgcIg0vp+VaywZHiQiQtV5dT5+XxVnWjAQ//UINqOS6dl7jYVTTVa4FvmLqrkti1eeZ65sjqOL8+m/UXk66e9D8ZdWmH/N5Yy65uvpaseiM1FoLBKZmHllJoVY67ssKZML3vda3r4NtnHekA0s0b7ZUJO95Yfmmj99timk+xwg4AinZM/Xed3T8vXgsKahpnLQcBpTRk1PuOKQBHNZ9mDUNwvPsb4d1NLMczsI/YPxPMa99SlcNMBvg+Y9h1Swti2oFgXuDdZq0nBKU1fndoU1OODhUr3EX2x2m8+XFYc2QXQN0o+pdfV3+Om9iTYDDMImUrZ3NOEdFGWdGPOX+XH43r7AWfUvFCmoPBtwp6JMlo79FPE75bP3eO/trcKSnnrsHWydZrcf+AxRZYifaO3J8HnYbuJUkqDIX8fiq8b4JZ5o9CBwJklQlEBzOurWgHyymRRvUDA+xKqothbEcn+SMfXVSAdbyvCnWHidUE564A0AHuKpxSBIhe4wZbRuA9jduusAlyWLOebSNocMmKHG6GFYt9HXE4/rW82mLOHwSxDV2HXlf5+iYL02vcd4wyFdUF2Lkv/WjADxGULur5sQ9A6PNXiPlEGda/ULZZsPrQIFL7A+bZhNc06uReKJjhdWStiKmpHVtdJl6XgTeeKSOarxTav5lbR8WnQWndXawyvBhDYMpf3g9bN93vsxLbgpcsZKpXVKWy5M+CKfXwWrmYK/Xz+pl/vWrGqCePU5tkB837JRlsth21y8a5N1hntMdY1jO18xDINHyoNUrwa6gH7zYbPgR4Uw+d553fsQdF5EQ3/gD0ohs/zzu/Yg6LzIhr+AXtQDJ/nnd+xB0XnRTT8A/agGD7PO7/jv5tY1jZOnnXsAAAAAElFTkSuQmCC" width="66.5" height="19" /></span><span class = "S5">.</span></p><p class = "S3"><span class = "S5">Note that the calculation of singular values is numerically expensive, especially for large stoichiometric matrices.</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% calculate the singular values</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">svVect = svds(S, rankS);</span></p></div></div><p class = "S13"><span class = "S5">The </span><span class = "S7">svds() </span><span class = "S5">function returns the number of singular values specified in the second argument of the function. As most stoichiometric matrices are rank deficient, some singular values are zero (or within numerical tolerances). The cut-off is located at the rank of the stoichiometric matrix. </span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% determine the vector with all singular values (including zeros)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">svVectAll = svds(S, min(nMets, nRxns));</span></p></div></div><p class = "S13"><span class = "S5">The singular values and their cut-off can be illustrated as follows:</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% plot the singular values</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">figure;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% plot the singular values up to rankS</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">semilogy(linspace(1, length(svVect), length(svVect)), svVect, </span><span class = "S12">'*'</span><span class = "S10">);</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% plot all singular values</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">hold </span><span class = "S12">on</span><span class = "S10">;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">semilogy(linspace(1, length(svVectAll), length(svVectAll)), svVectAll, </span><span class = "S12">'ro'</span><span class = "S10">);</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% set the font size of the current figure axes, show a legend and minor grid axes</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">set(gca, </span><span class = "S12">'fontsize'</span><span class = "S10">, 14);</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">legend(</span><span class = "S12">'svds (up to rankS)'</span><span class = "S11">, </span><span class = "S12">'svds (all)'</span><span class = "S10">)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">grid </span><span class = "S12">minor</span><span class = "S10">;</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% set the label</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">xlabel(</span><span class = "S12">'Number of the singular value'</span><span class = "S10">);</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">ylabel(</span><span class = "S12">'Magnitude of the singular value'</span><span class = "S10">);</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10"></span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">hold </span><span class = "S12">off</span><span class = "S10">;</span></p></div></div><p class = "S13"><span class = "S5">The</span><span class = "S2"> maximum singular</span><span class = "S5"> value is</span><span class = "S2"> </span><span class = "S5">the largest element on the diagonal matrix obtained from singular value decomposition. Similarly, the </span><span class = "S2">minimum singular value</span><span class = "S5"> is the smallest element on the diagonal matrix obtained from singular value decomposition. Only singular values greater than zero (numbered from </span><span class = "S7">1</span><span class = "S5"> to </span><span class = "S7">rank(S)</span><span class = "S5">) are of interest.</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% determine the maximum and minimum singular values</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">maxSingVal = svVect(1) </span><span class = "S18">% first value of the vector with singular values</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">minSingVal = svVect(rankS) </span><span class = "S18">% smallest non-zero singular value</span></p></div></div><p class = "S13"><span class = "S5">Alternatively, if the rank of the stoichiometric matrix </span><span class = "S7">S</span><span class = "S5"> is not known, the built-in functions can also be used: </span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">maxSingValBuiltIn = svds(S, 1)</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">minSingValBuiltIn = svds(S, 1, </span><span class = "S12">'smallestnz'</span><span class = "S10">)</span></p></div></div><p class = "S13"><span class = "S5">The </span><span class = "S2">condition number</span><span class = "S5"> of the stoi</span><span class = "S5">chiometric matrix is a ratio of the maximum and minimum singular values. The higher this ratio, the more ill-conditioned the stoichiometric matrix is (numerical issues) and, generally, the longer the simulation time is.</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% determine the condition number</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">condNumber = maxSingVal / minSingVal</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S3"><span class = "S2">Summary of model characteristics</span></p><p class = "S3"><span class = "S5">The following numerical properties have been calculated:</span></p><ul class = "S21"><li class = "S22"><span class = "S23">Number of elements</span><span class = "S0">: represents the total number of entries in the stoichiometric matrix (including zero elements). This number is equivalent to the product of the number of reactions and the number of metabolites.</span></li><li class = "S22"><span class = "S23">Number of nonzero elements</span><span class = "S0">: represents the total number of nonzero entries in the stoichiometric matrix (excluding zero elements).</span></li><li class = "S22"><span class = "S23">Sparsity ratio</span><span class = "S0">: ratio of the number of zero elements and the total number of elements. The sparser a stoichiometric matrix, the fewer metabolites participate in each reaction. The sparsity ratio is particularly useful to compare models by how many metabolites participate in each reaction.</span></li><li class = "S22"><span class = "S23">Complementary sparsity ratio</span><span class = "S0">: calculated as the difference of one and the sparsity ratio, and is the ratio of the number of nonzero elements and the total number of elements.</span></li><li class = "S22"><span class = "S23">Average column density</span><span class = "S0">: corresponds to the ratio of the number of nonzero elements in each column and the total number of metabolites. The average column density corresponds to the arithmetic average of all the column densities (sum of all the column densities divided by the number of reactions).</span></li><li class = "S22"><span class = "S23">Relative column density</span><span class = "S0">: corresponds to the ratio of the number of nonzero elements in each column and the total number of metabolites. The relative column density corresponds to the average column density divided by the total number of metabolites (expressed in parts-per-million (ppm)).</span></li><li class = "S22"><span class = "S23">Rank</span><span class = "S0">: the rank of a stoichiometric matrix is the maximum number of linearly independent rows and is equivalent to the number of linearly independent columns. The rank is a measurement of how many reactions and metabolites are linearly independent.</span></li><li class = "S22"><span class = "S23">Rank deficiency</span><span class = "S0">: the rank deficiency of the stoichiometric matrix is a measure of how many reactions and metabolites are linearly dependent, and expressed as the ratio of the rank of the stoichiometric matrix to the theoretical full rank.</span></li><li class = "S22"><span class = "S23">Maximum singular value</span><span class = "S0">: the largest element on the diagonal matrix obtained from singular value decomposition.</span></li><li class = "S22"><span class = "S23">Minimum singular value</span><span class = "S0">: the smallest element on the diagonal matrix obtained from singular value decomposition.</span></li><li class = "S22"><span class = "S23">Condition number</span><span class = "S0">: the condition number of the stoichiometric matrix is the ratio of the maximum and minimum singular values. The higher this ratio, the more ill-conditioned the stoichiometric matrix is (numerical issues).</span></li></ul><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">fprintf([</span><span class = "S12">' --- SUMMARY ---\n'</span><span class = "S11">,</span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span><span class = "S12">'Model file/Model name/Matrix name    %s/%s/%s\n'</span><span class = "S11">,</span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span><span class = "S12">'Size is [nMets, nRxns]               [%d, %d]\n'</span><span class = "S11">,</span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span><span class = "S12">'Number of elements:                  %d \n'</span><span class = "S11">,</span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span><span class = "S12">'Number of nonzero elements:          %d \n'</span><span class = "S11">,</span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span><span class = "S12">'Sparsity ratio [%%]:                  %1.2f \n'</span><span class = "S11">,</span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span><span class = "S12">'Complementary sparsity ratio [%%]     %1.2f \n'</span><span class = "S11">, </span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span><span class = "S12">'Average column density [ppm]:        %1.2f \n'</span><span class = "S11">,</span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span><span class = "S12">'Relative column density [ppm]:       %1.2f \n'</span><span class = "S11">,</span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span><span class = "S12">'Rank:                                %d \n'</span><span class = "S11">,</span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span><span class = "S12">'Rank deficiency [%%]:                 %1.2f \n'</span><span class = "S11">,</span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span><span class = "S12">'Maximum singular value:              %1.2f \n'</span><span class = "S11">,</span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span><span class = "S12">'Minimum singular value:              %1.2f \n'</span><span class = "S11">,</span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    </span><span class = "S12">'Condition number:                    %1.2f \n'</span><span class = "S11">,</span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    ],</span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    modelFile, modelName, matrixName, nMets, nRxns, nElem, nNz, sparsityRatio, </span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">    compSparsityRatio, colDensityAv, colDensityRel, rankS, rankDeficiencyS, </span><span class = "S20">...</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">    maxSingVal, minSingVal, condNumber);</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S3"><span class = "S2">Scaling</span></p><p class = "S3"><span class = "S5">The scaling estimate is based on the order of magnitude of the ratio of the maximum and minimum scaling coefficients, which are determined such that the scaled stoichiometric matrix has entries close to unity. In order to investigate the scaling of the stoichiometric matrix and provide an estimate of the most appropriate precision of the solver to be used, the following quantities should be calculated:</span></p><ul class = "S21"><li class = "S22"><span class = "S23">Estimation level: </span><span class = "S0">The estimation level, defined by the parameter scltol provides a measure of how accurate the estimation is. The estimation level can be </span><span class = "S24">crude</span><span class = "S0">, </span><span class = "S24">medium</span><span class = "S0">, or </span><span class = "S24">fine</span><span class = "S0">.</span></li><li class = "S22"><span class = "S23">Size of the matrix: </span><span class = "S0">The size of the matrix indicates the size of the metabolic network, and is broken down into number of metabolites and number of reactions.</span></li><li class = "S22"><span class = "S23">Stoichiometric coefficients:</span><span class = "S0"> The maximum and minimum values of the stoichiometric matrix provide a range of the stoichiometric coefficients and are determined based on all elements of the stoichiometric matrix. Their ratio (and its order of magnitude) provides valuable information on the numerical difficulty to solve a linear program.</span></li><li class = "S22"><span class = "S23">Lower bound coefficients: </span><span class = "S0">The maximum and minimum values of the lower bound vector provide a range of the coefficients of the lower bound vector. Their ratio (and its order of magnitude) provides valuable information on the numerical difficulty to solve a linear program.</span></li><li class = "S22"><span class = "S23">Upper bound coefficients: </span><span class = "S0">The maximum and minimum values of the upper bound vector provide a range of the coefficients of the upper bound vector. Their ratio (and its order of magnitude) provides valuable information on the numerical difficulty to solve a linear program.</span></li><li class = "S22"><span class = "S23">Row scaling coefficients: </span><span class = "S0">The row scaling coefficients are the scaling coefficients required to scale each row closer to unity. The maximum and minimum row scaling coefficients provide a range of row scaling coefficients required to scale the stoichiometric matrix row-wise. Their ratio (and its order of magnitude) provides valuable information on the numerical difficulty to solve a linear program. </span></li><li class = "S22"><span class = "S23">Column scaling coefficients: </span><span class = "S0">The column scaling coefficients are the scaling coefficients required to scale each column closer to unity. The maximum and minimum column scaling coefficients provide a range of column scaling coefficients required to scale the stoichiometric matrix column-wise. Their ratio (and its order of magnitude) provides valuable information on the numerical difficulty to solve a linear program.</span></li></ul><p class = "S3"><span class = "S5">The scaling properties of the stoichiometric matrix can be determined using:</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">[precisionEstimate, solverRecommendation] = checkScaling(model);</span></p></div></div><p class = "S13"><span class = "S5">The </span><span class = "S7">precisionEstimate</span><span class = "S5"> yields a recommended estimate of the precision of the solver:</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">precisionEstimate</span></p></div></div><p class = "S13"><span class = "S5">The solver recommendation is provided in </span><span class = "S7">solverRecommendation</span><span class = "S5"> as a cell array that  can be used programmatically:</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">solverRecommendation</span></p></div></div><p class = "S13"><span class = "S5">In order to see the effect of scaling, let us consider the ME model [4]:</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% load the modelName structure from the modelFile</span></p></div><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S11">load(</span><span class = "S12">'ME_matrix_GlcAer_WT.mat'</span><span class = "S11">, </span><span class = "S12">'modelGlcOAer_WT'</span><span class = "S10">);</span></p></div></div><p class = "S13"><span class = "S5">The scaling can be checked as follows:</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">[precisionEstimate, solverRecommendation] = checkScaling(modelGlcOAer_WT);</span></p></div></div><p class = "S13"><span class = "S5">In this case, the </span><span class = "S7">solverRecommendation</span><span class = "S5"> is:</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S10">solverRecommendation</span></p></div></div></div><p class = "S0"></p><div class = 'SectionBlock containment'><p class = "S3"><span class = "S5">The solver then can be set as as suggested to use the quad-precision solver:</span></p><div class = 'LineNodeBlock contiguous'><div class = 'inlineWrapper'><p class = "S9 lineNode"><span class = "S18">% changeCobraSolver(solverRecommendation{1});</span></p></div></div><p class = "S13"><span class = "S5">Note that the timing for obtaining a solution using a quad-precision solver is very different than obtaining the solution using a double-precision solver. </span></p></div><p class = "S0"></p><div class = 'SectionBlock containment'><h2 class = "S6"><span class = "S5">EXPECTED RESULTS</span></h2><p class = "S3"><span class = "S5">The expected result is a summary table with relevant numerical characteristics and a recommendation of the precision of the solver.</span></p></div><p class = "S0"></p><div class = 'SectionBlock containment'><h2 class = "S6"><span class = "S5">TROUBLESHOOTING</span></h2><p class = "S3"><span class = "S5">If any numerical issues arise (e.g., infeasible solution status after performing flux balance analysis, or too long simulation times) when using a double precision solver, then a higher precision solver should be tested. For instance, a double precision solver may incorrectly report that an ill-scaled optimisation problem is infeasible although it actually might be feasible for a higher precision solver. </span></p><p class = "S3"><span class = "S5">In some cases,  the precision recommendation might not be accurate enough and a double precision solver might lead to inaccurate results. Try a quad precision solver in order to confirm the results when in doubt.</span></p><p class = "S3"><span class = "S5">The </span><span class = "S7">checkScaling()</span><span class = "S5"> function may be used on all operating systems, but the </span><span class = "S7">'dqqMinos'</span><span class = "S5"> interface is only available on UNIX operating systems. If the </span><span class = "S7">'dqqMinos'</span><span class = "S5"> interface is not working as intended, the binaries might not be compatible (raise an issue if they are not by providing the output of </span><span class = "S7">generateSystemConfigReport</span><span class = "S5">). Make sure that all relevant system requirements are satisfied before trying to use the </span><span class = "S7">'dqqMinos'</span><span class = "S5"> solver interface.</span></p><p class = "S3"><span class = "S5">In case the </span><span class = "S7">'dqqMinos' </span><span class = "S5">interface reports an error when trying to solve the linear program, there might be an issue with the model itself.</span></p></div><p class = "S0"></p><div class = 'SectionBlock containment'><h2 class = "S6"><span class = "S5">References</span></h2><p class = "S3"><span class = "S5">[1] </span><a href = 'http://www.nature.com/nbt/journal/v31/n5/full/nbt.2488.html'><span class = "S25">Thiele et al., A community-driven global reconstruction of human metabolism, Nat Biotech, 2013.</span></a></p><p class = "S3"><span class = "S5">[2] Reconstruction and Use of Microbial Metabolic Networks: the Core Escherichia coli Metabolic Model as an Educational Guide by Orth, Fleming, and Palsson (2010)</span></p><p class = "S3"><span class = "S5">[3] P. E. Gill, W. Murray, M. A. Saunders and M. H. Wright (1987). Maintaining LU factors of a general sparse matrix, Linear Algebra and its Applications 88/89, 239-270.</span></p><p class = "S3"><span class = "S5">[4] Multiscale modeling of metabolism and macromolecular synthesis in E. coli and its application to the evolution of codon usage, Thiele et al., PLoS One, 7(9):e45635 (2012)</span></p></div></div>
<!-- 
##### SOURCE BEGIN #####
%% *Numerical properties of a reconstruction*
% *Authors: Laurent Heirendt, Ronan M.T. Fleming, Luxembourg Centre for Systems 
% Biomedicine*
% 
% *Reviewers: Sylvain Arreckx, Thomas Pfau, and Catherine Fleming,  Luxembourg 
% Centre for Systems Biomedicine*
%% Introduction
% During this tutorial, you will learn how to determine and explore the numerical 
% properties of a stoichiometric matrix. The numerical properties are key to analyzing 
% the metabolic reconstruction at hand, to select the appropriate solver, or to 
% determine incoherencies in the network. 
% 
% You will also be able to learn more about the definitions of the various 
% numerical characteristics. This tutorial is particularly useful when you have 
% a multi-scale model and are facing numerical issues when performing flux balance 
% analysis or any other variants of FBA.
%% EQUIPMENT SETUP
%% *Initialize the COBRA Toolbox.*
% Please ensure that The COBRA Toolbox has been properly installed, and initialized 
% using the |initCobraToolbox| function.

initCobraToolbox
%% *Setting the *optimization* solver.*
% This tutorial will be run with a |'glpk'| package, which is a linear programming 
% ('|LP'|) solver. The |'glpk'| package does not require additional instalation 
% and configuration.

solverName='glpk';
solverType='LP'; 
changeCobraSolver(solverName,solverType);
%% 
% There are no specific solvers essentail to running this tutorial. For 
% the analysis of large models, such as Recon [1], it is not recommended to use 
% the |'glpk'| package but rather an industrial strength solver, such as the |'gurobi'| 
% package. For detailed information, refer to The Cobra Toolbox <https://github.com/opencobra/cobratoolbox/blob/master/docs/source/installation/solvers.md 
% solver instalation guide>. 
% 
% A solver package may offer different types of optimization programmes to 
% solve a problem. The above example used a LP optimization, other types of optimization 
% programmes include; mixed-integer linear programming ('|MILP|'), quadratic programming 
% ('|QP|'), and mixed-integer quadratic programming ('|MIQP|').

warning off MATLAB:subscripting:noSubscriptsSpecified
%% PROCEDURE 
% TIMING: 5 seconds - several hours (depending on the model size)
% 
% *Define the name of the model*
% 
% Throughout this tutorial, we will use the _E.coli core_ model [2]. It is 
% generally good practice to define; the name of the file that contains the model, 
% the name of the model structure, and the name of the stoichiometric matrix, 
% as separate variables. Therefore, we propose that within the |modelFile|, there 
% is a structure named |modelName| with a field |matrixName| that contains the 
% stoichiometric matrix |S| (or |A|).

% define the filename of the model
modelFile = 'ecoli_core_model.mat';

% define the name of model structure
modelName = 'model';

% define the fieldname of the stoichiometric matrix
matrixName = 'S';
%% 
% *Load the stoichiometric matrix*
% 
% In order to use the model, we need to load the |modelFile| that contains 
% a COBRA model structure  |modelName|:

% load the modelName structure from the modelFile
load(modelFile, modelName);
%% 
% Some models contain stoichiometric matrices with a different name (commonly 
% coupled models). By default, the stoichiometric matrix is denoted |S|.

% select the matrix
S = model.S;
if isfield(model, matrixName) == 1 && strcmp(matrixName, 'A') == 1
    S = model.A;
end
%% 
% *Basic numerical characteristics*
% 
% The *number of elements* represents the total number of entries in the 
% stoichiometric matrix (including zero elements). This number is equivalent to 
% the product of the number of reactions and the number of metabolites.
% 
% The number of rows represents the *number of metabolites* in the metabolic 
% network. The number of columns corresponds to the *number of biochemical reactions* 
% in the network.

% determine the number of reactions and metabolites in S
[nMets, nRxns] = size(S)
% determine the number of elements in S
nElem = numel(S)  % Nmets * Nrxns
%% 
% The total number of nonzero elements corresponds to the total number of 
% nonzero entries in the stoichiometric matrix (excluding zero elements).

% determine the number of nonzero elements in S
nNz = nnz(S)
%% 
% *Sparsity and Density*
% 
% The *sparsity ratio* corresponds to a ratio of the number of zero elements 
% and the total number of elements. The sparser a stoichiometric matrix, the fewer 
% metabolites participate in each reaction. The sparsity ratio is particularly 
% useful to compare models by how many metabolites participate in each reaction.

% determine the sparsity ratio of S (in percent)
sparsityRatio = (1 - nNz / nElem) * 100.0  % [%]
%% 
% Similarly, the *complementary sparsity ratio* is calculated as the difference 
% of 100 and the sparsity ratio expressed in percent, and therefore, is a ratio 
% of the number of nonzero elements and the total number of elements.

% determine the complementary sparsity ratio (in percent)
compSparsityRatio = 100.0 - sparsityRatio  % [%]
%% 
% The* average column density *corresponds to a ratio of the number of nonzero 
% elements in each column (i.e. reaction) and the total number of metabolites. 
% The average column density corresponds to the arithmetic average of all the 
% column densities (sum of all the reaction densities divided by the number of 
% reactions).

% add the number of non-zeros in each column (reaction)
colDensityAv = 0;
for i = 1:nRxns
    colDensityAv = colDensityAv + nnz(S(:, i));
end

% calculate the arithmetic average number of non-zeros in each column
colDensityAv = colDensityAv / nRxns   % [-]
%% 
% The average column density provides a measure of how many stoichiometric 
% coefficients participate in each biochemical reaction on average.
% 
% The *relative column density* corresponds to the ratio of the number of 
% nonzero elements in each column and the total number of metabolites. The relative 
% column density corresponds to the average column density divided by the total 
% number of metabolites (expressed in percent). The relative column density may 
% also be expressed as parts-per-million [ppm] for large-scale or huge-scale models. 

% determine the density proportional to the length of the column
colDensityRel = colDensityAv / nMets * 100  % [%]
%% 
% The relative column density indicates how many metabolites are being used 
% on average in each reaction relative to the total number of metabolites in the 
% metabolic network.
% 
% *Sparsity Pattern (spy plot)*
% 
% The visualisation of the sparsity pattern is useful to explore the matrix, 
% spot inconsistencies, or identify patterns visually. In addition to the standard 
% sparsity pattern, the magnitude of the elements of the stoichiometric matrix 
% (stoichiometric coefficients) is shown as proportional to the size of the dot.

% print a colorful spy map of the S matrix
spyc(S, colormap(advancedColormap('cobratoolbox')));

% set the font size of the current figure axes
set(gca, 'fontsize', 14);
%% 
% In the case of the _E.coli core_ model [2],  the biomass reaction is clearly 
% visible (reaction number 13) due to its large amount of metabolites (dots in 
% the column) and large coefficients (size of the dots). Also, the metabolites 
% with large stoichiometric coefficients can be easily determined based on their 
% dot size.
% 
% *Rank*
% 
% The *rank* of a stoichiometric matrix is the maximum number of linearly 
% independent rows, and is equivalent to the number of linearly independent columns. 
% The rank is a measurement of how many reactions and metabolites are linearly 
% independent. 

% determine the rank of the stoichiometric matrix
if ispc
    rankS = rank(full(S))
else
    rankS = getRankLUSOL(S) % calculated using either the LUSOL solver [3]
end
%% 
% The *rank deficiency* of the stoichiometric matrix is a measure of how 
% many reactions and metabolites are not linearly dependent, and expressed as 
% a ratio of the rank of the stoichiometric matrix to the theoretical full rank.

% calculate the rank deficiency (in percent)
rankDeficiencyS = (1 - rankS / min(nMets, nRxns)) * 100  % [%]
%% 
% *Singular Values and Condition Number*
% 
% A singular value decomposition of the stoichiometric matrix is the decomposition 
% into orthonormal matrices $<math xmlns="http://www.w3.org/1998/Math/MathML" 
% display="inline"><mrow><mi mathvariant="italic">U</mi></mrow></math>$ (of dimension 
% |nMets| by |nMets|) and $<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi 
% mathvariant="italic">V</mi></mrow></math>$ (of dimension |nRxns| by |nRxns|), 
% and a matrix with diagonal elements $<math xmlns="http://www.w3.org/1998/Math/MathML" 
% display="inline"><mrow><mi mathvariant="italic">D</mi></mrow></math>$ such that 
% $<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline"><mrow><mi 
% mathvariant="normal">S = UD</mi><msup><mrow><mi mathvariant="italic">V</mi></mrow><mrow><mi 
% mathvariant="italic">T</mi></mrow></msup></mrow></math>$.
% 
% Note that the calculation of singular values is numerically expensive, 
% especially for large stoichiometric matrices.

% calculate the singular values
svVect = svds(S, rankS);
%% 
% The |svds() |function returns the number of singular values specified 
% in the second argument of the function. As most stoichiometric matrices are 
% rank deficient, some singular values are zero (or within numerical tolerances). 
% The cut-off is located at the rank of the stoichiometric matrix. 

% determine the vector with all singular values (including zeros)
svVectAll = svds(S, min(nMets, nRxns));
%% 
% The singular values and their cut-off can be illustrated as follows:

% plot the singular values
figure;

% plot the singular values up to rankS
semilogy(linspace(1, length(svVect), length(svVect)), svVect, '*');

% plot all singular values
hold on;
semilogy(linspace(1, length(svVectAll), length(svVectAll)), svVectAll, 'ro');

% set the font size of the current figure axes, show a legend and minor grid axes
set(gca, 'fontsize', 14);
legend('svds (up to rankS)', 'svds (all)')
grid minor;

% set the label
xlabel('Number of the singular value');
ylabel('Magnitude of the singular value');

hold off;
%% 
% The* maximum singular* value is* *the largest element on the diagonal 
% matrix obtained from singular value decomposition. Similarly, the *minimum singular 
% value* is the smallest element on the diagonal matrix obtained from singular 
% value decomposition. Only singular values greater than zero (numbered from |1| 
% to |rank(S)|) are of interest.

% determine the maximum and minimum singular values
maxSingVal = svVect(1) % first value of the vector with singular values
minSingVal = svVect(rankS) % smallest non-zero singular value
%% 
% Alternatively, if the rank of the stoichiometric matrix |S| is not known, 
% the built-in functions can also be used: 

maxSingValBuiltIn = svds(S, 1)
minSingValBuiltIn = svds(S, 1, 'smallestnz')
%% 
% The *condition number* of the stoichiometric matrix is a ratio of the 
% maximum and minimum singular values. The higher this ratio, the more ill-conditioned 
% the stoichiometric matrix is (numerical issues) and, generally, the longer the 
% simulation time is.

% determine the condition number
condNumber = maxSingVal / minSingVal
%% 
% *Summary of model characteristics*
% 
% The following numerical properties have been calculated:
% 
% * *Number of elements*: represents the total number of entries in the stoichiometric 
% matrix (including zero elements). This number is equivalent to the product of 
% the number of reactions and the number of metabolites.
% * *Number of nonzero elements*: represents the total number of nonzero entries 
% in the stoichiometric matrix (excluding zero elements).
% * *Sparsity ratio*: ratio of the number of zero elements and the total number 
% of elements. The sparser a stoichiometric matrix, the fewer metabolites participate 
% in each reaction. The sparsity ratio is particularly useful to compare models 
% by how many metabolites participate in each reaction.
% * *Complementary sparsity ratio*: calculated as the difference of one and 
% the sparsity ratio, and is the ratio of the number of nonzero elements and the 
% total number of elements.
% * *Average column density*: corresponds to the ratio of the number of nonzero 
% elements in each column and the total number of metabolites. The average column 
% density corresponds to the arithmetic average of all the column densities (sum 
% of all the column densities divided by the number of reactions).
% * *Relative column density*: corresponds to the ratio of the number of nonzero 
% elements in each column and the total number of metabolites. The relative column 
% density corresponds to the average column density divided by the total number 
% of metabolites (expressed in parts-per-million (ppm)).
% * *Rank*: the rank of a stoichiometric matrix is the maximum number of linearly 
% independent rows and is equivalent to the number of linearly independent columns. 
% The rank is a measurement of how many reactions and metabolites are linearly 
% independent.
% * *Rank deficiency*: the rank deficiency of the stoichiometric matrix is a 
% measure of how many reactions and metabolites are linearly dependent, and expressed 
% as the ratio of the rank of the stoichiometric matrix to the theoretical full 
% rank.
% * *Maximum singular value*: the largest element on the diagonal matrix obtained 
% from singular value decomposition.
% * *Minimum singular value*: the smallest element on the diagonal matrix obtained 
% from singular value decomposition.
% * *Condition number*: the condition number of the stoichiometric matrix is 
% the ratio of the maximum and minimum singular values. The higher this ratio, 
% the more ill-conditioned the stoichiometric matrix is (numerical issues).

fprintf([' REPLACE_WITH_DASH_DASH- SUMMARY REPLACE_WITH_DASH_DASH-\n',...
    'Model file/Model name/Matrix name    %s/%s/%s\n',...
    'Size is [nMets, nRxns]               [%d, %d]\n',...
    'Number of elements:                  %d \n',...
    'Number of nonzero elements:          %d \n',...
    'Sparsity ratio [%%]:                  %1.2f \n',...
    'Complementary sparsity ratio [%%]     %1.2f \n', ...
    'Average column density [ppm]:        %1.2f \n',...
    'Relative column density [ppm]:       %1.2f \n',...
    'Rank:                                %d \n',...
    'Rank deficiency [%%]:                 %1.2f \n',...
    'Maximum singular value:              %1.2f \n',...
    'Minimum singular value:              %1.2f \n',...
    'Condition number:                    %1.2f \n',...
    ],...
    modelFile, modelName, matrixName, nMets, nRxns, nElem, nNz, sparsityRatio, ...
    compSparsityRatio, colDensityAv, colDensityRel, rankS, rankDeficiencyS, ...
    maxSingVal, minSingVal, condNumber);
%% 
% *Scaling*
% 
% The scaling estimate is based on the order of magnitude of the ratio of 
% the maximum and minimum scaling coefficients, which are determined such that 
% the scaled stoichiometric matrix has entries close to unity. In order to investigate 
% the scaling of the stoichiometric matrix and provide an estimate of the most 
% appropriate precision of the solver to be used, the following quantities should 
% be calculated:
% 
% * *Estimation level: *The estimation level, defined by the parameter scltol 
% provides a measure of how accurate the estimation is. The estimation level can 
% be _crude_, _medium_, or _fine_.
% * *Size of the matrix: *The size of the matrix indicates the size of the metabolic 
% network, and is broken down into number of metabolites and number of reactions.
% * *Stoichiometric coefficients:* The maximum and minimum values of the stoichiometric 
% matrix provide a range of the stoichiometric coefficients and are determined 
% based on all elements of the stoichiometric matrix. Their ratio (and its order 
% of magnitude) provides valuable information on the numerical difficulty to solve 
% a linear program.
% * *Lower bound coefficients: *The maximum and minimum values of the lower 
% bound vector provide a range of the coefficients of the lower bound vector. 
% Their ratio (and its order of magnitude) provides valuable information on the 
% numerical difficulty to solve a linear program.
% * *Upper bound coefficients: *The maximum and minimum values of the upper 
% bound vector provide a range of the coefficients of the upper bound vector. 
% Their ratio (and its order of magnitude) provides valuable information on the 
% numerical difficulty to solve a linear program.
% * *Row scaling coefficients: *The row scaling coefficients are the scaling 
% coefficients required to scale each row closer to unity. The maximum and minimum 
% row scaling coefficients provide a range of row scaling coefficients required 
% to scale the stoichiometric matrix row-wise. Their ratio (and its order of magnitude) 
% provides valuable information on the numerical difficulty to solve a linear 
% program. 
% * *Column scaling coefficients: *The column scaling coefficients are the scaling 
% coefficients required to scale each column closer to unity. The maximum and 
% minimum column scaling coefficients provide a range of column scaling coefficients 
% required to scale the stoichiometric matrix column-wise. Their ratio (and its 
% order of magnitude) provides valuable information on the numerical difficulty 
% to solve a linear program.
% 
% The scaling properties of the stoichiometric matrix can be determined using:

[precisionEstimate, solverRecommendation] = checkScaling(model);
%% 
% The |precisionEstimate| yields a recommended estimate of the precision 
% of the solver:

precisionEstimate
%% 
% The solver recommendation is provided in |solverRecommendation| as a cell 
% array that  can be used programmatically:

solverRecommendation
%% 
% In order to see the effect of scaling, let us consider the ME model [4]:

% load the modelName structure from the modelFile
load('ME_matrix_GlcAer_WT.mat', 'modelGlcOAer_WT');
%% 
% The scaling can be checked as follows:

[precisionEstimate, solverRecommendation] = checkScaling(modelGlcOAer_WT);
%% 
% In this case, the |solverRecommendation| is:

solverRecommendation
%% 
% The solver then can be set as as suggested to use the quad-precision solver:

% changeCobraSolver(solverRecommendation{1});
%% 
% Note that the timing for obtaining a solution using a quad-precision solver 
% is very different than obtaining the solution using a double-precision solver. 
%% EXPECTED RESULTS
% The expected result is a summary table with relevant numerical characteristics 
% and a recommendation of the precision of the solver.
%% TROUBLESHOOTING
% If any numerical issues arise (e.g., infeasible solution status after performing 
% flux balance analysis, or too long simulation times) when using a double precision 
% solver, then a higher precision solver should be tested. For instance, a double 
% precision solver may incorrectly report that an ill-scaled optimisation problem 
% is infeasible although it actually might be feasible for a higher precision 
% solver. 
% 
% In some cases,  the precision recommendation might not be accurate enough 
% and a double precision solver might lead to inaccurate results. Try a quad precision 
% solver in order to confirm the results when in doubt.
% 
% The |checkScaling()| function may be used on all operating systems, but 
% the |'dqqMinos'| interface is only available on UNIX operating systems. If the 
% |'dqqMinos'| interface is not working as intended, the binaries might not be 
% compatible (raise an issue if they are not by providing the output of |generateSystemConfigReport|). 
% Make sure that all relevant system requirements are satisfied before trying 
% to use the |'dqqMinos'| solver interface.
% 
% In case the |'dqqMinos' |interface reports an error when trying to solve 
% the linear program, there might be an issue with the model itself.
%% References
% [1] <http://www.nature.com/nbt/journal/v31/n5/full/nbt.2488.html Thiele et 
% al., A community-driven global reconstruction of human metabolism, Nat Biotech, 
% 2013.>
% 
% [2] Reconstruction and Use of Microbial Metabolic Networks: the Core Escherichia 
% coli Metabolic Model as an Educational Guide by Orth, Fleming, and Palsson (2010)
% 
% [3] P. E. Gill, W. Murray, M. A. Saunders and M. H. Wright (1987). Maintaining 
% LU factors of a general sparse matrix, Linear Algebra and its Applications 88/89, 
% 239-270.
% 
% [4] Multiscale modeling of metabolism and macromolecular synthesis in E. 
% coli and its application to the evolution of codon usage, Thiele et al., PLoS 
% One, 7(9):e45635 (2012)
##### SOURCE END #####
--></body></html>